
# ch03. 字符串、向量和数组























## 命名空间的using声明

> **头文件不应包含using声明**  
> 位于头文件的代码（参见2.6.3节，第67页）一般来说不应该使用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个using声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。
























## 标准库类型string

### 定义和初始化string对象

> 如果使用等号（=）初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化（direct initialization）。


### string对象上的操作

> getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。getline只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。  
> 和输入运算符一样，getline也会返回它的流参数。因此既然输入运算符能作为判断的条件（参见1.4.3节，第13页），我们也能用getline的结果作为条件。


string::size_type是无符号的, C++11中可推断具体类型. 

> 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型string的对象。切记，字符串字面值与string是不同的类型。

### 处理string对象中的字符

> 建议：使用C++版本的C标准库头文件  
> C++标准库中除了定义C++语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。  
> 因此，cctype头文件和ctype.h头文件的内容是一样的，只不过从命名规范上来讲更符合C++语言的要求。特别的，在名为cname的头文件中定义的名字从属于命名空间std，而定义在名为.h的头文件中的则不然。  
> 一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。如果使用.h形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。  

使用基于范围的for语句




























### 标准库类型vector

> vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如`vector<int>`。

> vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象（参见2.3.1节，第45页），所以不存在包含引用的vector。除此之外，其他大多数（非引用）内置类型和类类型都可以构成vector对象，甚至组成vector的元素也可以是vector。
> 
> 需要指出的是，在早期版本的C++标准中如果vector的元素还是vector（或者其他模板类型），则其定义的形式与现在的C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如应该写成`vector<vector<int> >`而非`vector<vector<int>>`。

> 某些编译器可能仍需以老式的声明语句来处理元素为vector的vector对象，如`vector<vector<int> >`。

### 定义和初始化vector对象


> 之前已经讲过，C++语言提供了几种不同的初始化方式（参见2.2.1节，第39页）。在大多数情况下这些初始化方式可以相互等价地使用，不过也并非一直如此。目前已经介绍过的两种例外情况是：其一，使用拷贝初始化时（即使用=时）（参见3.2.1节，第76页），只能提供一个初始值；其二，如果提供的是一个类内初始值（参见2.6.1节，第64页），则只能使用拷贝初始化或使用花括号的形式初始化。第三种特殊的要求是，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里


> 在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。例如，用一个整数来初始化`vector<int>`时，整数的含义可能是vector对象的容量也可能是元素的值。类似的，用两个整数来初始化`vector<int>`时，这两个整数可能一个是vector对象的容量，另一个是元素的初值，也可能它们是容量为2的vector对象中两个元素的初值。通过使用花括号或圆括号可以区分上述这些含义：  
> ```cpp
> vector<int> v1(10);      // v1有10个元素, 每个值都是0
> vector<int> v2{10};      // v1有1个元素, 该元素的值是10
> vector<int> v3(10, 1);   // v1有10个元素, 每个值都是1
> vector<int> v4{10, 1};   // v1有2个元素, 值分别是10和1
> ```
> 如果用的是圆括号，可以说提供的值是用来构造（construct）vector对象的。例如，v1的初始值说明了vector对象的容量；v3的两个初始值则分别说明了vector对象的容量和元素的初值。  
> 如果用的是花括号，可以表述成我们想列表初始化（list initialize）该vector对象。也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。在上例中，给v2和v4提供的初始值都能作为元素的值，所以它们都会执行列表初始化，vector对象v2包含一个元素而vector对象v4包含两个元素。  
> 另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。例如，要想列表初始化一个含有string对象的vector对象，应该提供能赋给string对象的初值。此时不难区分到底是要列表初始化vector对象的元素还是用给定的容量值来构造vector对象：  
> ```cpp
> vector<string> v5{"hi"};      // 列表初始化: v5有一个元素
> vector<string> v6("hi");      // 错误: 不能使用字符串字面值构建vector对象
> vector<string> v7{10};        // v7有10个默认初始化的元素
> vector<string> v8{10, "hi"};  // v8有10个值为"hi"的元素
> ```
> 尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只有v5是列表初始化。要想列表初始化vector对象，花括号里的值必须与元素类型相同。显然不能用int初始化string对象，所以v7和v8提供的值不能作为元素的初始值。确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。


### 向vector对象中添加元素

> 对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个vector对象的副本、所有元素的初始值都一样。

> 向vector对象添加元素蕴含的编程假定  
> 由于能高效便捷地向vector对象中添加元素，很多编程工作被极大简化了。然而，这种简便性也伴随着一些对编写程序更高的要求：其中一条就是必须要确保所写的循环正确无误，特别是在循环有可能改变vector对象容量的时候。  
> 随着对vector的更多使用，我们还会逐渐了解到其他一些隐含的要求，其中一条是现在就要指出的：如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环，具体原因将在5.4.3节（第168页）详细解释。  
> 
> **范围for语句体内不应改变其所遍历序列的大小。**

### 其他vector操作

> vector对象（以及string对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。

> 提示：只能对确知已存在的元素执行下标操作！





























## 迭代器介绍

### 使用迭代器

> end成员则负责返回指向容器（或string对象）“尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“尾后（off the end）”元素。这样的迭代器没什么实际含义，仅是个标记而已，表示我们已经处理完了容器中的所有元素。end成员返回的迭代器常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则begin和end返回的是同一个迭代器。

> 因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。

> 关键概念：泛型编程  
> 原来使用C或Java的程序员在转而使用C++语言之后，会对for循环中使用！=而非<进行判断有点儿奇怪，比如上面的这个程序以及85页的那个。C++程序员习惯性地使用！=，其原因和他们更愿意使用迭代器而非下标的原因一样：因为这种编程风格在标准库提供的所有容器上都有效。  
> 之前已经说过，只有string和vector等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了==和！=，但是它们中的大多数都没有定义<运算符。因此，只要我们养成使用迭代器和！=的习惯，就不用太在意用的到底是哪种容器类型。

> 某些对vector对象的操作会使迭代器失效  
> 3.3.2节（第90页）曾经介绍过，虽然vector对象可以动态地增长，但是也会有一些副作用。已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效。9.3.6节（第315页）将详细解释迭代器是如何失效的。
> 
> 
> **谨记，但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。**

### 迭代器运算

> 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。


这里有一份用迭代器写的二分算法. 


























## 数组

### 定义和初始化内置数组

#### 显式初始化数组元素

#### 字符数组的特殊性

#### 不允许拷贝和赋值

#### 理解复杂的数组声明

> 和vector一样，数组能存放大多数类型的对象。例如，可以定义一个存放指针的数组。又因为数组本身就是对象，所以允许定义数组的指针及数组的引用。在这几种情况中，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂一点了：
> ```cpp
> int *ptrs[10];            // ptrs是含有10个整形指针的数组
> int &refs[10] = /* ? */;  // 错误: 不存在引用的数组
> int (*Parray)[10] = &arr; // Parray指向一个含有10个整数点数组
> int (&arrRef)[10] = arr;  // arrRef引用一个含有10个整数点数组
> ```
> 默认情况下，类型修饰符从右向左依次绑定。对于ptrs来说，从右向左（参见2.3.3节，第52页）理解其含义比较简单：首先知道我们定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针。  
> 但是对于Parray来说，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解Parray的含义：首先是圆括号括起来的部分，＊Parray意味着Parray是个指针，接下来观察右边，可知道Parray是个指向大小为10的数组的指针，最后观察左边，知道数组中的元素是int。这样最终的含义就明白无误了，Parray是一个指针，它指向一个int数组，数组中包含10个元素。同理，（&arrRef）表示arrRef是一个引用，它引用的对象是一个大小为10的数组，数组中元素的类型是int。  
> 当然，对修饰符的数量并没有特殊限制：  
> ```cpp
> int *(&arry)[10] = ptrs; // arry是数组的引用, 该数组含有10个指针
> ```
> 按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然后观察右边知道，arry引用的对象是一个大小为10的数组，最后观察左边知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。

> **Tip：要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。**

### 访问数组元素

> 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。

### 指针和数组

> 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

> 在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个auto（参见2.5.2节，第61页）变量的初始值时，推断得到的类型是指针而非数组
>
> 
> 必须指出的是，当使用decltype关键字（参见2.5.3节，第62页）时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组： 
> ```cpp
> // ia3是一个含有10个整数的数组
> decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
> ia3 = p;     // 错误: 不能用整型指针给数组赋值
> ia3[4] = i;  // 正确: 把i的值赋给ia3的一个元素
> ```

#### 指针也是迭代器

#### 标准库函数begin和end

> C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员（参见3.4.1节，第95页）功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数


#### 指针运算

> 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型。

#### 解引用和指针运算的交互


#### 下标和指针

> 下标和指针如前所述，在很多情况下使用数组的名字其实用的是一个指向数组首元素的指针。一个典型的例子是当对数组使用下标运算符时，编译器会自动执行上述转换操作。给定  
> ```cpp
> int ia[] = {0, 2, 4, 6, 8}; // 含有5个整数的数组
> ```  
> 此时，ia[0]是一个使用了数组名字的表达式，对数组执行下标运算其实是对指向数组元素的指针执行下标运算：   
> ```cpp
> int i = ia[2]; // ia转换成指向数组首元素的指针
>                // ia[2]得到(ia + 2)所指的元素
> int *p = ia;   // p指向ia的首元素
> i = *(p + 2);  // 等价于i = ia[2]
> ```
> 只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：  
> ```cpp
> int *p = &ia[2]; // p指向索引为2的元素
> int j = p[1];    // p[1]等价于*(p+1), 就是ia[3]表示的那个元素
> int k = p[-2];   // p[-2]是ia[0]表示的那个元素
> ```
> 虽然标准库类型string和vector也能执行下标运算，但是数组与它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，上面的最后一个例子很好地说明了这一点。内置的下标运算符可以处理负值，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。

> 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。


### C风格字符串

> 尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

#### C标准库String函数

### 与旧代码的接口

#### 混用string对象和C风格字符串

> 3.2.1节（第76页）介绍过允许使用字符串字面值来初始化string对象：  
> ```cpp
> string s("Hello World"); // s的内容是Hello World
> ```
> 更一般的情况是，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：  
> · 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。  
> · 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。
> 
> 上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用string对象来代替它。例如，不能用string对象直接初始化指向字符的指针。为了完成该功能，string专门提供了一个名为c_str的成员函数：  
> ```cpp
> char *str = s; // 错误: 不能用string对象初始化char*
> const char *str = s.c_str(); // 正确
> ```
> 顾名思义，c_str函数的返回值是一个C风格的字符串。也就是说，函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个string对象的一样。结果指针的类型是const char＊，从而确保我们不会改变字符数组的内容。  
> 我们无法保证c_str函数返回的数组一直有效，事实上，如果后续的操作改变了s的值就可能让之前返回的数组失去效用。
> 

#### 使用数组初始化vector对象

> 建议：尽量使用标准库类型而非数组
> 
> 使用指针和数组很容易出错。一部分原因是概念上的问题：指针常用于底层操作，因此容易引发一些与烦琐细节有关的错误。其他问题则源于语法错误，特别是声明指针时的语法错误。
> 
> 现代的C++程序应当尽量使用vector和迭代器，避免使用内置数组和指针；应该尽量使用string，避免使用C风格的基于数组的字符串。



























## 多维数组

> 严格来说，C++语言中没有多维数组，通常所说的多维数组其实是数组的数组。谨记这一点，对今后理解和使用多维数组大有益处。


> **要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。**



























## 小结































## 术语表



> begin 是string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。  
> 
> 缓冲区溢出（buffer overflow）一种严重的程序故障，主要的原因是试图通过一个越界的索引访问容器内容，容器类型包括string、vector和数组等。  
> 
> C风格字符串（C-style string）以空字符结束的字符数组。字符串字面值是C风格字符串，C风格字符串容易出错。  
> 
> 类模板（class template）用于创建具体类类型的模板。要想使用类模板，必须提供关于类型的辅助信息。例如，要定义一个vector对象需要指定元素的类型：`vector<int>`包含int类型的元素。  
> 
> 编译器扩展（compiler extension）某个特定的编译器为C++语言额外增加的特性。基于编译器扩展编写的程序不易移植到其他编译器上。  
> 
> 容器（container） 是一种类型，其对象容纳了一组给定类型的对象。vector是一种容器类型。  
> 
> 拷贝初始化（copy initialization） 使用赋值号（=）的初始化形式。新创建的对象是初始值的一个副本。
> 
> difference_type由string和vector定义的一种带符号整数类型，表示两个迭代器之间的距离。  
> 
> 直接初始化（direct initialization）不使用赋值号（=）的初始化形式。  
> 
> empty是string和vector的成员，返回一个布尔值。当对象的大小为0时返回真，否则返回假。  
> 
> end是string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一位置的指针。  
> 
> getline 在string头文件中定义的一个函数，以一个istream对象和一个string对象为输入参数。该函数首先读取输入流的内容直到遇到换行符停止，然后将读入的数据存入string对象，最后返回istream对象。其中换行符读入但是不保留。  
> 
> 索引（index） 是下标运算符使用的值。表示要在string对象、vector对象或者数组中访问的一个位置。  
> 
> 实例化（instantiation） 编译器生成一个指定的模板类或函数的过程。  
> 
> 迭代器（iterator） 是一种类型，用于访问容器中的元素或者在元素之间移动。
> 
> 迭代器运算（iterator arithmetic） 是string或vector的迭代器的运算：迭代器与整数相加或相减得到一个新的迭代器，与原来的迭代器相比，新迭代器向前或向后移动了若干个位置。两个迭代器相减得到它们之间的距离，此时它们必须指向同一个容器的元素或该容器尾元素的下一位置。  
> 
> 以空字符结束的字符串（null-terminated string） 是一个字符串，它的最后一个字符后面还跟着一个空字符（'\0'）。  
> 
> 尾后迭代器（off-the-end iterator） end函数返回的迭代器，指向一个并不存在的元素，该元素位于容器尾元素的下一位置。  
> 
> 指针运算（pointer arithmetic） 是指针类型支持的算术运算。指向数组的指针所支持的运算种类与迭代器运算一样。  
> 
> ptrdiff_t 是cstddef头文件中定义的一种与机器实现有关的带符号整数类型，它的空间足够大，能够表示数组中任意两个指针之间的距离。  
> 
> push_back 是vector的成员，向vector对象的末尾添加元素。  
> 
> 范围for语句（range for） 一种控制语句，可以在值的一个特定集合内迭代。
> 
> size 是string和vector的成员，分别返回字符的数量或元素的数量。返回值的类型是size_type。
> 
> size_t 是cstddef头文件中定义的一种与机器实现有关的无符号整数类型，它的空间足够大，能够表示任意数组的大小。
> 
> size_type 是string和vector定义的类型的名字，能存放下任意string对象或vector对象的大小。在标准库中，size_type被定义为无符号类型。
> 
> string 是一种标准库类型，表示字符的序列。
> 
> using声明（using declaration） 令命名空间中的某个名字可被程序直接使用。`using 命名空间::名字;` 上述语句的作用是令程序可以直接使用名字，而无须写它的前缀部分命名空间`::`。
> 
> 值初始化（value initialization） 是一种初始化过程。内置类型初始化为0，类类型由类的默认构造函数初始化。只有当类包含默认构造函数时，该类的对象才会被值初始化。对于容器的初始化来说，如果只说明了容器的大小而没有指定初始值的话，就会执行值初始化。此时编译器会生成一个值，而容器的元素被初始化为该值。
> 
> vector 是一种标准库类型，容纳某指定类型的一组元素。
> 
> ++运算符（++ operator）是迭代器和指针定义的递增运算符。执行“加1”操作使得迭代器指向下一个元素。
> 
> [ ]运算符（[ ] operator）下标运算符。obj[j]得到容器对象obj中位置j的那个元素。索引从0开始，第一个元素的索引是0，尾元素的索引是obj.size（）-1。下标运算符的返回值是一个对象。如果p是指针、n是整数，则p[n]与＊（p+n）等价。
> 
> ->运算符（->operator）箭头运算符，该运算符综合了解引用操作和点操作。a->b等价于（＊a）.b。
> 
> <<运算符（<< operator）标准库类型string定义的输出运算符，负责输出string对象中的字符。
> 
> **>> 运算符**（>>operator）标准库类型string定义的输入运算符，负责读入一组字符，遇到空白停止，读入的内容赋给运算符右侧的运算对象，该运算对象应该是一个string对象。
> 
> ！运算符（！ operator）逻辑非运算符，将它的运算对象的布尔值取反。如果运算对象是假，则结果为真，如果运算对象是真，则结果为假。
> 
> &&运算符（&&operator）逻辑与运算符，如果两个运算对象都是真，结果为真。只有当左侧运算对象为真时才会检查右侧运算对象。
> 
> ||运算符（|| operator）逻辑或运算符，任何一个运算对象是真，结果就为真。只有当左侧运算对象为假时才会检查右侧运算对象。
> 
































