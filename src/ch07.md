
# ch07. 类


















## 定义抽象数据类型

### 设计Sales_data类

### 定义改进的Sales_data类

> 定义在类内部的函数是隐式的inline函数（参见6.5.2节，第214页）。

> 成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。

> C++语言的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。

> 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

> 译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。

### 定义类相关的非成员函数

> 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。


### 拷贝、赋值和析构




















## 访问控制与封装

> 作为接口的一部分，构造函数和部分成员函数（即isbn和combine）紧跟在public说明符之后；而数据成员和作为实现部分的函数则跟在private说明符后面。
> 
> 一个类可以包含0个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

### 友元

> 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可

> 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。我们将在7.3.4节（第250页）介绍更多关于友元的知识。

> 一般来说，最好在类定义开始或结束前的位置集中声明友元。

#### 关键概念：封装的益处

> 封装有两个重要的优点：  
> · 确保用户代码不会无意间破坏封装对象的状态。  
> · 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。
> 
> 一旦把数据成员定义成private的，类的作者就可以比较自由地修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确认这次改变有什么影响；换句话说，只要类的接口不变，用户代码就无须改变。如果数据是public的，则所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码，之后才能重新使用该程序。
> 
> 把数据成员的访问权限设成private还有另外一个好处，这么做能防止由于用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，将查错限制在有限范围内将能极大地降低维护代码及修正程序错误的难度。

#### 友元的声明

> 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。
> 
> 为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。


















## 类的其他特性

### 类成员再探

#### 可变数据成员

> 可变数据成员
> 
> 有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。
> 
> 一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。举个例子，我们将给Screen添加一个名为access_ctr的可变成员，通过它我们可以追踪每个Screen的成员函数被调用了多少次：
> ```cpp
> class Screen {
>  public:
>   void some_member() const;
>  private:
>   mutable size_t access_ctr; // 即使在一个const对象内也能被修改
>   // 其他成员与之前的版本一致
> }; 
> void Screen::some_member() const {
>   ++access_ctr;  // 保存一个计数值, 用于记录成员函数被调用的次数
>   // 该成员需要完成的其他工作
> }
> ```
> 尽管some_member是一个const成员函数，它仍然能够改变access_ctr的值。该成员是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值。

#### 类数据成员的初始值

> 当我们提供一个类内初始值时，必须以符号=或者花括号表示。

### 返回*this的成员函数

> 返回引用的函数是左值的（参见6.3.2节，第202页），意味着这些函数返回的是对象本身而非对象的副本。

#### 从const成员函数返回*this

> 一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。

#### 基于const的重载

#### 建议：对于公共代码使用私有功能函数

### 类类型

> 每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。
> 
> 即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其他任何类（或者任何其他作用域）的成员都不是一回事儿。

#### 类的声明

> 就像可以把函数的声明和定义分离开来一样（参见6.1.2节，第186页），我们也能仅仅声明类而暂时不定义它：
> ```cpp
> class Screen; // Screen类的声明
> ```
> 这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。

### 友元再探

> 我们的Sales_data类把三个普通的非成员函数定义成了友元（参见7.2.1节，第241页）。类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

#### 类之间的友元关系

> 必须要注意的一点是，友元关系不存在传递性。
>
> 每个类负责控制自己的友元类或友元函数。

#### 令成员函数作为友元

> 当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类
> 
> 要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。

#### 函数重载和友元

> 尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明

#### 友元声明和作用域

> 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中（参见7.2.1节，第241页）。
> 
> 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的：
> ```cpp
> struct X{
>   friend void f() {/*友元函数可以定义在类的内部*/}
>   X() {f();}              // 错误: f还没有被声明
>   void g();
>   void h();
> };
> void X::g() {return f();} // 错误: f还没有被声明
> void f();                 // 声明那个定义在X中的函数
> void X::h() {return f();} // 正确: 现在f的声明在作用域中
> ```
> 关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。



















## 类的作用域

### 名字查找与类的作用域


> 对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别，不过在当前的这个例子中体现得不太明显。类的定义分两步处理：  
> · 首先，编译成员的声明。  
> · 直到类全部可见后才编译函数体。
> 
> 编译器处理完类中的全部声明后才会处理成员函数的定义。
> 
> 按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。相反，如果函数的定义和成员的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。

#### 用于类成员声明的名字查找

> 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。

#### 类型名要特殊处理

> 一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字

> 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

#### 成员定义中的普通块作用域的名字查找

> 成员函数中使用的名字按照如下方式解析：  
> · 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。  
> · 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。  
> · 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。

#### 类作用域之后，在外围的作用域中查找

> 尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。

#### 在文件中名字的出现处对其进行解析

当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。




















## 构造函数再探

### 构造函数初始值列表

#### 构造函数的初始值

> 有时必不可少有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

> 如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

#### 建议：使用构造函数初始值

> 在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。
> 
> 除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。

#### 成员初始化的顺序

> 成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。

> 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。

#### 默认实参和构造函数

> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

### 委托构造函数

> C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。
> 
> 和其他构造函数一样，一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。
>
> 
> 假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。

### 默认构造函数的作用

> 当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：  
> · 当我们在块作用域内不使用任何初始值定义一个非静态变量（参见2.2.1节，第39页）或者数组时（参见3.5.1节，第101页）。  
> · 当一个类本身含有类类型的成员且使用合成的默认构造函数时（参见7.1.4节，第235页）。  
> · 当类类型的成员没有在构造函数初始值列表中显式地初始化时（参见7.1.4节，第237页）。
> 
> 值初始化在以下情况下发生：  
> · 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时（参见3.5.1节，第101页）。  
> · 当我们不使用初始值定义一个局部静态变量时（参见6.1.1节，第185页）。  
> · 当我们通过书写形如T（ ）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小（参见3.3.1节，第88页），它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。

> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。


#### 使用默认构造函数

> 如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对.

### 隐式的类类型转换

> 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数（converting constructor）。

#### 只允许一步类类型转换

> 在4.11.2节（第143页）中我们指出，编译器只会自动地执行一步类型转换。

#### 类类型转换不是总有效

#### 抑制构造函数定义的隐式转换

> 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止
>
> 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复

#### explicit构造函数只能用于直接初始化

> 当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用（参见3.2.1节，第76页）。而且，编译器将不会在自动转换过程中使用该构造函数。

#### 为转换显式地使用构造函数

> 使用static_cast（参见4.11.3节，第145页）执行了显式的而非隐式的转换。

#### 标准库中含有显式构造函数的类

> 我们用过的一些标准库中的类含有单参数的构造函数：  
> · 接受一个单参数的const char＊的string构造函数（参见3.2.1节，第76页）不是explicit的。  
> · 接受一个容量参数的vector构造函数（参见3.3.1节，第87页）是explicit的。



















### 聚合类

> 聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：  
> · 所有成员都是public的。  
> · 没有定义任何构造函数。  
> · 没有类内初始值（参见2.6.1节，第64页）。  
> · 没有基类，也没有virtual函数，关于这部分知识我们将在第15章详细介绍。

### 字面值常量类

> 在6.5.2节（第214页）中我们提到过constexpr函数的参数和返回值必须是字面值类型。除了算术类型、引用和指针外，某些类也是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，它们是隐式const的（参见7.1.2节，第231页）。
> 
> 数据成员都是字面值类型的聚合类（参见7.5.5节，第266页）是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：  
> · 数据成员都必须是字面值类型。  
> · 类必须至少含有一个constexpr构造函数。  
> · 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式（参见2.4.4节，第58页）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。  
> · 类必须使用析构函数的默认定义，该成员负责销毁类的对象（参见7.1.5节，第239页）。

#### constexpr构造函数

> 尽管构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。
> 
> constexpr构造函数可以声明成= default（参见7.1.4节，第237页）的形式（或者是删除函数的形式，我们将在13.1.6节（第449页）介绍相关知识）。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句（参见6.5.2节，第214页））。综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了。 
> 
> constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。


















## 类的静态成员

#### 声明静态成员

> 我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。

> 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
> 
> 类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。

#### 使用类的静态成员

> 我们使用作用域运算符直接访问静态成员
> 
> 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员
> 
> 成员函数不用通过作用域运算符就能直接使用静态成员

#### 定义静态成员

> 和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句

> 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。
> 
> 类似于全局变量（参见6.1.1节，第184页），静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。

> 我们定义静态数据成员的方式和在类的外部定义成员函数差不多。我们需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字

> 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。

#### 静态成员的类内初始化

> 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr（参见7.5.6节，第267页）。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度. 

> 如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了

> 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

#### 静态成员能用于某些场景，而普通成员不能

> 特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用
> 
> 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参（参见6.5.1节，第211页）
>
> 
















## 小结



















## 术语表

> 抽象数据类型（abstract data type） 封装（隐藏）了实现细节的数据结构。
> 
> 访问说明符（access specifier） 包括关键字public和private。用于定义成员对类的用户可见还是只对类的友元和成员可见。在类中说明符可以出现多次，每个说明符的有效范围从它自身开始，到下一个说明符为止。
> 
> 聚合类（aggregate class） 只含有公有成员的类，并且没有类内初始值或者构造函数。聚合类的成员可以用花括号括起来的初始值列表进行初始化。
> 
> 类（class） C++提供的自定义数据类型的机制。类可以包含数据、函数和类型成员。一个类定义一种新的类型和一个新的作用域。
> 
> 类的声明（class declaration） 首先是关键字class（或者struct），随后是类名以及分号。如果类已经声明而尚未定义，则它是一个不完全类型。
> 
> class关键字（class keyword） 用于定义类的关键字，默认情况下成员是private的。
> 
> 类的作用域（class scope） 每个类定义一个作用域。类作用域比其他作用域更加复杂，类中定义的成员函数甚至有可能使用定义语句之后的名字。
>
> 常量成员函数（const member function） 一个成员函数，在其中不能修改对象的普通（即既不是static也不是mutable）数据成员。const成员的this指针是指向常量的指针，通过区分函数是否是const可以进行重载。
> 
> 构造函数（constructor） 用于初始化对象的一种特殊的成员函数。构造函数应该给每个数据成员都赋一个合适的初始值。
> 
> 构造函数初始值列表（constructor initializer list）说明一个类的数据成员的初始值，在构造函数体执行之前首先用初始值列表中的值初始化数据成员。未经初始值列表初始化的成员将被默认初始化。
> 
> 转换构造函数（converting constructor） 可以用一个实参调用的非显式构造函数。这样的函数隐式地将参数类型转换成类类型。
> 
> 数据抽象（data abstraction） 着重关注类型接口的一种编程技术。数据抽象令程序员可以忽略类型的实现细节，只关注类型执行的操作即可。数据抽象是面向对象编程和泛型编程的基础。
> 
> 默认构造函数（default constructor） 当没有提供任何实参时使用的构造函数。
>
> 委托构造函数（delegating constructor） 委托构造函数的初始值列表只有一个入口，指定类的另一个构造函数执行初始化操作。
> 
> 封装（encapsulation） 分离类的实现与接口，从而隐藏了类的实现细节。在C++语言中，通过把实现部分设为private完成封装的任务。
> 
> 显式构造函数（explicit constructor） 可以用一个单独的实参调用但是不能用于隐式转换的构造函数。通过在构造函数的声明之前加上explicit关键字就可以将其声明成显式构造函数。
> 
> 前向声明（forward declaration） 对尚未定义的名字的声明，通常用于表示位于类定义之前的类声明。参见“不完全类型”。
> 
> 友元（friend）类向外部提供其非公有成员访问权限的一种机制。友元的访问权限与成员函数一样。友元可以是类，也可以是函数。
> 
> 实现（implementation）类的成员（通常是私有的），定义了不希望为使用类类型的代码所用的数据及任何操作。
> 
> 不完全类型（incomplete type） 已经声明但是尚未定义的类型。不完全类型不能用于定义变量或者类的成员，但是用不完全类型定义指针或者引用是合法的。
>
> 接口（interface） 类型提供的（公有）操作。通常情况下，接口不包含数据成员。
> 
> 成员函数（member function） 类的函数成员。普通的成员函数通过隐式的this指针与类的对象绑定在一起；静态成员函数不与对象绑定在一起也没有this指针。成员函数可以重载，此时隐式的this指针参与函数匹配的过程。
> 
> 可变数据成员（mutable data member） 这种成员永远不是const，即使它属于const对象。在const函数内可以修改可变数据成员。
> 
> 名字查找（name lookup） 根据名字的使用寻找匹配的声明的过程。
> 
> 私有成员（private member） 定义在private访问说明符之后的成员，只能被类的友元或者类的其他成员访问。数据成员以及仅供类本身使用而不作为接口的功能函数一般设为private。
> 
> 公有成员（public member） 定义在public访问说明符之后的成员，可以被类的所有用户访问。通常情况下，只有实现类的接口的函数才被设为public。
> 
> struct关键字（struct keyword） 用于定义类的关键字，默认情况下成员是public的。
>
> 合成默认构造函数（synthesized default constructor） 对于没有显式地定义任何构造函数的类，编译器为其创建（合成）的默认构造函数。该构造函数检查类的数据成员，如果提供了类内初始值，就用它执行初始化操作；否则就对数据成员执行默认初始化。
> 
> this指针（this pointer） 是一个隐式的值，作为额外的实参传递给类的每个非静态成员函数。this指针指向代表函数调用者的对象。
> 
> = default 一种语法形式，位于类内部默认构造函数声明语句的参数列表之后，要求编译器生成构造函数，而不管类是否已经有了其他构造函数。





















