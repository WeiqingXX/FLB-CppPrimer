
# ch06. 函数


















## 函数基础

> 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序（参见4.1.3节，第123页）。编译器能以任意可行的顺序对实参求值。

### 局部对象

> 形参和函数体内部定义的变量统称为局部变量（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会隐藏（hide）在外层作用域中同名的其他所有声明中。


#### 局部静态对象

> 某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。

> 如果局部静态变量没有显式的初始值，它将执行值初始化（参见3.3.1节，第88页），内置类型的局部静态变量初始化为0。

### 函数声明

> 函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。
> 
> 因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。尽管如此，写上形参的名字还是有用处的，它可以帮助使用者更好地理解函数的功能


### 分离式编译


















## 参数传递

### 传值参数

> 熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针。

### 传引用参数

#### 使用引用避免拷贝

> 如果函数无须改变引用形参的值，最好将其声明为常量引用。

#### 使用引用形参返回额外信息

> 一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。

### const形参和实参

#### 尽量使用常量引用

> 把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。


### 数组形参

> 数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组（参见3.5.1节，第102页）以及使用数组时（通常）会将其转换成指针（参见3.5.3节，第105页）。因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

管理指针形参有三种常用的技术。
- 使用标记指定数组长度
- 使用标准库规范
- 显式传递一个表示数组大小的形参

> 管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串（参见3.5.4节，第109页）。
>
> 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发，关于其细节将在第II部分详细介绍。
>
> 第三种管理数组实参的方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。

#### 数组形参和const

#### 数组引用形参

> &arr两端的括号必不可少
> ```cpp
> f(int &arr[10])    // 错误: 将arr声明成了引用的数组
> f(int (&arr)[10])  // 正确: arr是具有10个整数点整型数组的应用
> ```

#### 传递多维数组


### main：处理命令行选项

```cpp
int main(int argc, char *argvp[]) {}
int main(int argc, char **argvp) {}
```

> 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。
> 
> 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。

### 含有可变形参的函数

> 为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节（第618页）介绍。
> 
> C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。本节将简要介绍省略符形参，不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。

#### initializer_list形参

#### 省略符形参

> 省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。
> 
> **省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。**
> 
> 省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：
> ```cpp
> void foo(parm_list, ...);
> void foo(...);
> ```
> 第一种形式指定了foo函数的部分形参的类型，对应于这些形参的实参将会执行正常的类型检查。省略符形参所对应的实参无须类型检查。在第一种形式中，形参声明后面的逗号是可选的。




















## 返回类型和return语句

### 无返回值函数

### 有返回值函数

#### 值是如何被返回的

> 返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

#### 不要返回局部对象的引用或指针

#### 返回类类型的函数和调用运算符

> 和其他运算符一样，调用运算符也有优先级和结合律（参见4.1.2节，第121页）。调用运算符的优先级与点运算符和箭头运算符（参见4.6节，第133页）相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员。

#### 引用返回左值

> 函数的返回类型决定函数调用是否是左值（参见4.1.1节，第121页）。调用一个返回引用的函数得到左值，其他返回类型得到右值。

#### 列表初始化返回值

> C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化（参见3.3.1节，第88页）；否则，返回的值由函数的返回类型决定。

#### 主函数main的返回值

> 之前介绍过，如果函数的返回类型不是void，那么它必须返回一个值。但是这条规则有个例外：我们允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。
> 
> 如1.1节（第2页）介绍的，main函数的返回值可以看做是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量（参见2.3.2节，第49页），我们可以使用这两个变量分别表示成功与失败：
> ```cpp
> int main {
>   if (some_failure)
>     return EXIT_FAILURE;    // 定义在cstdlib头文件中
>   else 
>     return EXIT_SUCCESS;    // 定义在cstdlib头文件中
> }
> ```
> 因为它们是预处理变量，所以既不能在前面加上std：：，也不能在using声明中出现。

#### 递归

### 返回数组指针

> 因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用（参见3.5.1节，第102页）。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名（参见2.5.1节，第60页）

#### 声明一个返回数组指针的函数

> 要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：
> ```cpp
> int arr[10];             // arr是一个含有10个整数的数组
> int *p1[10];             // p1是一个含有10个指针的数组
> int (*p2)[10] = &arr;    // p2是一个指针, 它指向含有10个整数的数组
> ```
> 和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：
> ```cpp
> Type (*function(parameter_list))[dimension];
> ```
> 类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小。（*function（parameter_list））两端的括号必须存在，就像我们定义p2时两端必须有括号一样。如果没有这对括号，函数的返回类型将是指针的数组。
> 
> 举个具体点的例子，下面这个func函数的声明没有使用类型别名：
> ```cpp
> int (*func(int i))[10];
> ```
> 可以按照以下的顺序来逐层理解该声明的含义：  
> · func(int i)表示调用func函数时需要一个int类型的实参。  
> · (*func(int i))意味着我们可以对函数调用的结果执行解引用操作。  
> · (*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组。  
> · int (*func(int i))[10]表示数组中的元素是int类型。

#### 使用尾置返回类型

> 在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：
> ```cpp
> // func接受一个int类型的实参, 返回一个指针, 该指针指向含有10个整数的数组
> auto func(int i) -> int(*)[10];
> ```
> 因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。

#### 使用decltype

> 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：
> ```cpp
> int odd[] = {1, 3, 5, 7, 9};
> int even[] = {0, 2, 4, 6, 8};
> // 返回一个指针, 该指针指向含有5个整数的数组
> decltype(odd) *arrPtr(int i) {
>   return (i % 2) ? &odd : &even; // 返回一个指向数组的指针
> }
> ```
> arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有一个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号。




















## 函数重载

> 如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。


#### 定义重载函数

> 不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的

#### 判断两个形参的类型是否相异

> 类型别名（参见2.5.1节，第60页）为已存在的类型提供另外一个名字，它并不是创建新类型。

#### 重载和const形参

> 重载和const形参
> 
> 如6.2.3节（第190页）介绍的，顶层const（参见2.4.3节，第57页）不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：
> ```cpp
> Record lookup(Phone);
> Record lookup(const Phone);      // 重复声明了Record lookup(Phone)
> 
> Record lookup(Phone*);
> Record lookup(Phone* const);     // 重复声明了Record lookup(Phone*);
> ```
> 在这两组函数声明中，每一组的第二个声明和第一个声明是等价的。
> 
> 另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的：
> ```cpp
> // 对于接受引用或指针的函数来说, 对象是常量还是非常量对应的形参不同
> // 定义了4个独立的重载函数
> Record lookup(Account&);          // 函数作用域Account的引用
> Record lookup(const Account&);    // 新函数, 作用域常量引用
> 
> Record lookup(Account*);          // 新函数, 作用于指向Account的指针
> Record lookup(const Account*);    // 新函数, 作用域指向常量的指针
> ```
> 在上面的例子中，编译器可以通过实参是否是常量来推断应该调用哪个函数。因为const不能转换成其他类型（参见4.11.2节，第144页），所以我们只能把const对象（或指向const的指针）传递给const形参。相反的，因为非常量可以转换成const，所以上面的4个函数都能作用于非常量对象或者指向非常量对象的指针。不过，如6.6.1节（第220页）将要介绍的，**当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。**

#### 建议：何时不应该重载函数

> 尽管函数重载能在一定程度上减轻我们为函数起名字、记名字的负担，但是最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使得程序更易理解。

#### const_cast和重载

> 在4.11.3节（第145页）中我们说过，const_cast在重载函数的情景中最有用。

#### 调用重载的函数

> 函数匹配（function matching）是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做重载确定（overload resolution）。

> 现在我们需要掌握的是，当调用重载函数时有三种可能的结果：  
> · 编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。  
> · 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配（no match）的错误信息。  
> · 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用（ambiguous call）。

### 重载与作用域

> 一般来说，将函数声明置于局部作用域内不是一个明智的选择。

> 在C++语言中，名字查找发生在类型检查之前。




















## 特殊用途语言特性

### 默认实参

> 某些函数有这样一种形参，在函数的很多次调用中它们都被赋予一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参（default argument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。

> 默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。


#### 使用默认实参调用函数

> 函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。

> 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。


#### 默认实参声明

> 在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。


#### 默认实参初始值

> 局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参：
> ```cpp
> // wd, def和ht的声明必须出现在函数之外
> sz wd = 80;
> char def = ' ';
> sz ht();
> string screen(sz = ht(), sz = wd, char = def);
> 
> string widow = screen(); // 调用screen(ht(), 80, ' ' )
> ```
> 
> 用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：
> ```cpp
> void f2() {
>   def = '*';           // 改变默认实参的值
>   sz wd = 100;         // 隐藏了外层定义的wd, 带式没有改变默认值
>   window = screen();   // 调用screen(ht(), 80, '*')
> }
> 我们在函数f2内部改变了def的值，所以对screen的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的wd，但是该局部变量与传递给screen的默认实参没有任何关系。

### 内联函数和constexpr函数

#### 内联函数可避免函数调用的开销

> 将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。

在函数的返回类型前面加上关键字inline，这样就可以将它声明成内联函数了

> 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

> 一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个75行的函数也不大可能在调用点内联地展开。

#### constexpr函数

> constexpr函数（constexpr function）是指能用于常量表达式（参见2.4.4节，第58页）的函数。定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（参见2.4.4节，第59页），而且函数体中必须有且只有一条return语句

> 为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。

> constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名（参见2.5.1节，第60页）以及using声明。

> constexpr函数不一定返回常量表达式。

#### 把内联函数和constexpr函数放在头文件内

> 和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。

### 调试帮助

#### assert预处理宏

> assert是一种预处理宏（preprocessor marco）。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：
> ```cpp
> assert(expr);
> ```
> 首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。
> 
> assert宏定义在cassert头文件中。如我们所知，预处理名字由预处理器而非编译器管理（参见2.3.2节，第49页），因此我们可以直接使用预处理名字而无须提供using声明。也就是说，我们应该使用assert而不是std：：assert，也不需要为assert提供using声明。

> assert宏常用于检查“不能发生”的条件。

#### NDEBUG预处理变量

> assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。
> 
> 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：
> ```shell
> $ CC -D NDEBUG main.c # use /D with the Microsoft compiler
> ```
> 这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。

> 编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。
> 
> 除了C++编译器定义的__func__之外，预处理器还定义了另外4个对于程序调试很有用的名字：  
> __FILE__ 存放文件名的字符串字面值。  
> __LINE__ 存放当前行号的整型字面值。  
> __TIME__ 存放文件编译时间的字符串字面值。  
> __DATE__ 存放文件编译日期的字符串字面值。



















## 函数匹配

#### 确定候选函数和可行函数

> 函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。
>
> 第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。
>
> 在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。

> 如果没找到可行函数，编译器将报告无匹配函数的错误。

#### 寻找最佳匹配（如果有的话）

> 函数匹配的第三步是从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。下一节将介绍“最匹配”的细节，它的基本思想是，实参类型与形参类型越接近，它们匹配得越好。

#### 含有多个形参的函数匹配

> 编译器依次检查每个实参以确定哪个函数是最佳匹配。如果有且只有一个函数满足下列条件，则匹配成功：  
> · 该函数每个实参的匹配都不劣于其他可行函数需要的匹配。  
> · 至少有一个实参的匹配优于其他可行函数提供的匹配。  
> 如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。

> 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。


### 实参类型转换

> 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：  
> 1.精确匹配，包括以下情况：  
> · 实参类型和形参类型相同。  
> · 实参从数组类型或函数类型转换成对应的指针类型（参见6.7节，第221页，将介绍函数指针）。  
> · 向实参添加顶层const或者从实参中删除顶层const。  
> 2.通过const转换实现的匹配（参见4.11.2节，第143页）。  
> 3.通过类型提升实现的匹配（参见4.11.1节，第142页）。  
> 4.通过算术类型转换（参见4.11.1节，第142页）或指针转换（参见4.11.2节，第143页）实现的匹配。  
> 5.通过类类型转换实现的匹配（参见14.9节，第514页，将详细介绍这种转换）。

#### 需要类型提升和算术类型转换的匹配


#### 函数匹配和const实参

> 如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数





















## 函数指针

> 函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。

> 要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可

> *pf两端的括号必不可少。

#### 使用函数指针

> 当我们把函数名作为一个值使用时，该函数自动地转换成指针。例如，按照如下形式我们可以将lengthCompare的地址赋给pf：
> ```cpp
> pf = lengthCompare;  // pf指向名为lengthCompare的函数
> pf = &lengthCompare; // 等价的赋值语句: 取地址符是可选的
> ```
> 此外，我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针：
> ```cpp
> bool b1 = pf("hello", "goodbye");            // 调用lengthCompare函数
> bool b1 = (*pf)("hello", "goodbye");         // 一个等价的调用
> bool b1 = lengthCompare("hello", "goodbye"); // 另一个等价的调用
> ```

> 在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr（参见2.3.2节，第48页）或者值为0的整型常量表达式，表示该指针没有指向任何一个函数

#### 重载函数的指针

> 当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针
> 
> 编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配

#### 函数指针形参

> 和数组类似（参见6.2.4节，第193页），虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用：
> ```cpp
> // 第三个形参是函数类型, 它会自动地转换成指向函数的指针
> void useBigger(const string &s1, const string &s2, 
>                bool pf(const string &, const string &));
> //等价的声明, 显式地将形参定义成指向函数的指针
> void useBigger(const string &s1, const string &s2, 
>                bool (*pf)(const string &, const string &));
> ```
> 我们可以直接把函数作为实参使用，此时它会自动转换成指针：
> ```cpp
> // 自动将函数lengthCompare转换成指向该函数的指针
> useBigger(s1, s2, lengthCompare);
> ```
> 正如useBigger的声明语句所示，直接使用函数指针类型显得冗长而烦琐。类型别名（参见2.5.1节，第60页）和decltype（参见2.5.3节，第62页）能让我们简化使用了函数指针的代码：
> ```cpp
> // Func 和 Func2 是函数类型
> typedef bool Func(const string &, const string &);
> typedef decltype(lengthCompare) Func2;            // 等价的类型
> // FuncP 和 FuncP2 是函数类型
> typedef bool (*FuncP)(const string &, const string &);
> typedef decltype(lengthCompare) *FuncP2;          // 等价的类型
> ```
> 我们使用typedef定义自己的类型。Func和Func2是函数类型，而FuncP和FuncP2是指针类型。需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换成指针类型。因为decltype的结果是函数类型，所以只有在结果前面加上＊才能得到指针。可以使用如下的形式重新声明useBigger：
> ```cpp
> // useBigger的等价声明, 其中使用了类型别名
> void useBigger(const string &, const string &, Func);
> void useBigger(const string &, const string &, FuncP2);
> ```
> 这两个声明语句声明的是同一个函数，在第一条语句中，编译器自动地将Func表示的函数类型转换成指针。

#### 返回指向函数的指针

> 和数组类似（参见6.3.3节，第205页），虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：
> ```cpp
> using F = int(int *, int);     // F是函数类型, 不是指针
> using PF = int(*)(int *, int); // PF是指针类型
> ```
> 其中我们使用类型别名（参见2.5.1节，第60页）将F定义成函数类型，将PF定义成指向函数类型的指针。必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针：
> ```cpp
> PF f1(int);  // 正确: PF是指向函数的指针, f1返回指向函数的指针
> F f1(int);   // 错误: F是函数类型, f1不能返回一个函数
> F *f1(int);  // 正确: 显式地指定返回类型是指向函数的指针
> ```
> 当然，我们也能用下面的形式直接声明f1：
> ```cpp
> int (*f1(int))(int *, int);
> ```
> 按照由内向外的顺序阅读这条声明语句：我们看到f1有形参列表，所以f1是个函数；f1前面有*，所以f1返回一个指针；进一步观察发现，指针的类型本身也包含形参列表，因此指针指向函数，该函数的返回类型是int。
> 
> 出于完整性的考虑，有必要提醒读者我们还可以使用尾置返回类型的方式（参见6.3.3节，第206页）声明一个返回函数指针的函数：
> ```cpp
> auto f1(int) -> int (*)(int *, int);
> ```

#### 将auto和decltype用于函数指针类型

> 如果我们明确知道返回的函数是哪一个，就能使用decltype简化书写函数指针返回类型的过程。例如假定有两个函数，它们的返回类型都是string：：size_type，并且各有两个const string&类型的形参，此时我们可以编写第三个函数，它接受一个string类型的参数，返回一个指针，该指针指向前两个函数中的一个：
> ```cpp
> string::size_type sumLength(const string &, const string &);
> string::size_type largerLength(const string &, const string &);
> // 根据其形参的取值, getFcn函数返回指向sumLength或者largerLength的指针
> decltype(sumLength) *getFcn(const string &);
> ```
> 声明getFcn唯一需要注意的地方是，牢记当我们将decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们显式地加上*以表明我们需要返回指针，而非函数本身。




















## 小结




















## 术语表

> 二义性调用（ambiguous call） 是一种编译时发生的错误，造成二义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配。
> 
> 实参（argument） 函数调用时提供的值，用于初始化函数的形参。
> 
> Assert 是一个预处理宏，作用于一条表示条件的表达式。当未定义预处理变量NDEBUG时，assert对条件求值。如果条件为假，输出一条错误信息并终止当前程序的执行。
> 
> 自动对象（automatic object） 仅存在于函数执行过程中的对象。当程序的控制流经过此类对象的定义语句时，创建该对象；当到达了定义所在的块的末尾时，销毁该对象。
> 
> 最佳匹配（best match） 从一组重载函数中为调用选出的一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差。
> 
> 传引用调用（call by reference） 参见引用传递。
> 
> 传值调用（call by value） 参见值传递。
>
> 候选函数（candidate function） 解析某次函数调用时考虑的一组函数。候选函数的名字应该与函数调用使用的名字一致，并且在调用点候选函数的声明在作用域之内。
> 
> constexpr 可以返回常量表达式的函数，一个constexpr函数被隐式地声明成内联函数。
> 
> 默认实参（default argument） 当调用缺少了某个实参时，为该实参指定的默认值。
> 
> 可执行文件（executable file） 是操作系统能够执行的文件，包含着与程序有关的代码。
> 
> 函数（function）可调用的计算单元。
> 
> 函数体（function body） 是一个块，用于定义函数所执行的操作。
> 
> 函数匹配（function matching） 编译器解析重载函数调用的过程，在此过程中，实参与每个重载函数的形参列表逐一比较。
> 
> 函数原型（function prototype） 函数的声明，包含函数名字、返回类型和形参类型。要想调用某函数，在调用点之前必须声明该函数的原型。
> 
> 隐藏名字（hidden name） 某个作用域内声明的名字会隐藏掉外层作用域中声明的同名实体。
>
> initializer_list 是一个标准类，表示的是一组花括号包围的类型相同的对象，对象之间以逗号隔开。
> 
> 内联函数（inline function） 请求编译器在可能的情况下在调用点展开函数。内联函数可以避免常见的函数调用开销。
> 
> 链接（link）是一个编译过程，负责把若干对象文件链接起来形成可执行程序。
> 
> 局部静态对象（local static object） 它的值在函数调用结束后仍然存在。在第一次使用局部静态对象前创建并初始化它，当程序结束时局部静态对象才被销毁。
> 
> 局部变量（local variable） 定义在块中的变量。
> 
> 无匹配（no match）是一种编译时发生的错误，原因是在函数匹配过程中所有函数的形参都不能与调用提供的实参匹配。
> 
> 对象代码（object code） 编译器将我们的源代码转换成对象代码格式。
> 
> 对象文件（object file）编译器根据给定的源文件生成的保存对象代码的文件。一个或多个对象文件经过链接生成可执行文件。
>
> 对象生命周期（object lifetime） 每个对象都有相应的生命周期。块内定义的非静态对象的生命周期从它的定义开始，到定义所在的块末尾为止。程序启动后创建全局对象，程序控制流经过局部静态对象的定义时创建该局部静态对象；当main函数结束时销毁全局对象和局部静态对象。
> 
> 重载确定（overload resolution） 参见函数匹配。
> 
> 重载函数（overloaded function） 函数名与其他函数相同的函数。多个重载函数必须在形参数量或形参类型上有所区别。
> 
> 形参（parameter） 在函数的形参列表中声明的局部变量。用实参初始化形参。
> 
> 引用传递（pass by reference） 描述如何将实参传递给引用类型的形参。引用形参和其他形式的引用工作机理类似，形参被绑定到相应的实参上。
> 
> 值传递（pass by value） 描述如何将实参传递给非引用类型的形参。非引用类型的形参实际上是相应实参值的一个副本。
> 
> 预处理宏（preprocessor macro）类似于内联函数的一种预处理功能。除了assert之外，现代C++程序很少再使用预处理宏了。
>
> 递归循环（recursion loop）描述某个递归函数没有终止条件，因而不断调用自身直至耗尽程序栈空间的过程。
> 
> 递归函数（recursive function） 直接或间接调用自身的函数。
> 
> 返回类型（return type）是函数声明的一部分，用于指定函数返回值的类型。
> 
> 分离式编译（separate compilation） 把一个程序分割成多个独立源文件的能力。
> 
> 尾置返回类型（trailing return type） 在参数列表后面指定的返回类型。
> 
> 可行函数（viable function）是候选函数的子集。可行函数能匹配本次调用，它的形参数量与调用提供的实参数量相等，并且每个实参类型都能转换成相应的形参类型。
> 
> （）运算符（（） operator） 调用运算符，用于执行某函数。括号前面是函数名或函数指针，括号内是以逗号隔开的实参列表（可能为空）。
>
> 






















