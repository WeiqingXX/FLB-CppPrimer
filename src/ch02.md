
# ch02. 变量和基本类型






















## 基本内置类型

> C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合，例如最常见的是，当函数不返回任何值时使用空类型作为返回类型。

### 算术类型

> 算术类型分为两类：整型（integral type，包括字符和布尔类型在内）和浮点型。

> 与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。特别需要注意的是：类型char和类型signed char并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。

### 类型转换

> 提示：切勿混用带符号类型和无符号类型



### 字面值常量

> 整型字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是int、long和long long中尺寸最小的那个（例如，三者当中最小是int），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型short没有对应的字面值。在表2.2（第37页）中，我们将以后缀代表相应的字面值类型。


> 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式：
> ```cpp
> // 分多行书写的字符串字面值 
> std::cout << "a really, really long string literal "
>              "that spans two lines" << std::endl; 
> ```

> 我们也可以使用泛化的转义序列，其形式是\x后紧跟1个或多个十六进制数字，或者\后紧跟1个、2个或3个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是Latin-1字符集，以下是一些示例：
> [插图]
> 我们可以像使用普通字符那样使用C++语言定义的转义序列：
> [插图]
> [插图]
> 注意，如果反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列。例如，"\1234"表示2个字符，即八进制数123对应的字符以及字符4。相反，\x要用到后面跟着的所有数字，例如，"\x1234"表示一个16位的字符，该字符由这4个十六进制数所对应的比特唯一确定。因为大多数机器的char型数据占8位，所以上面这个例子可能会报错。一般来说，超过8位的十六进制字符都是与表2.2中某个前缀作为开头的扩展字符集一起使用的。


**表2.2**必须熟悉. 





















## 变量

### 变量定义

> 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

> 列表初始化
> C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为units_sold的int变量并初始化为0，以下的4条语句都可以做到这一点：
> ```cpp
> int units_sold = 0;
> int units_sold = {0};
> int units_sold{0};
> int units_sold(0);
> ```

从C++11开始用花括号进行列表初始化得到全面应用. 
但当用于内置类型变量时, 若使用列表初始化且初始值存在丢失信息的风险则编译器会报错. 

> **建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。**

### 变量声明和定义的关系

> 为了支持分离式编译，C++语言将声明和定义区分开来。声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。
> 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
> 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量：
> ```cpp
> extern int i;  // 声明i而非定义i
> int j;         // 声明并定义j
> ```
> 任何包含了显式初始化的声明即成为定义。我们能给由extern关键字标记的变量赋一个初始值，但是这么做也就抵消了extern的作用。extern语句如果包含初始值就不再是声明，而变成定义了：
> `extern double pi = 3.1416; // 定义`
> 在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。
> **变量能且只能被定义一次，但是可以被多次声明。**
> 声明和定义的区别看起来也许微不足道，但实际上却非常重要。如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。


### 标识符

标识符长度没有限制，但是对大小写字母敏感. 

> 如表2.3和表2.4所示，C++语言保留了一些名字供语言本身使用，这些名字不能被用作标识符。
> 同时，C++也为标准库保留了一些名字。用户自定义的标识符中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。

> 变量命名规范
> 变量命名有许多约定俗成的规范，下面的这些规范能有效提高程序的可读性：
> · 标识符要能体现实际含义。
> · 变量名一般用小写字母，如index，不要使用Index或INDEX。
> · 用户自定义的类名一般以大写字母开头，如Sales_item。
> · 如果标识符由多个单词组成，则单词间应有明显区分，如student_loan或studentLoan，不要使用studentloan。

### 名字的作用域

> 建议：当你第一次使用变量时再定义它

> 如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。
























## 复合类型


### 引用

> 引用即别名
> 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。

> 因为引用本身不是一个对象，所以不能定义引用的引用。

### 指针

> 得到空指针最直接的办法就是用字面值nullptr来初始化指针，这也是C++11新标准刚刚引入的一种方法。nullptr是一种特殊类型的字面值，它可以被转换成（参见2.1.2节，第32页）任意其他的指针类型。


> 建议：**初始化所有指针**
> ...
> 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为nullptr或者0，这样程序就能检测并知道它没有指向任何具体的对象了。b

> `void *` 是一种特殊的指针类型，可用于存放任意对象的地址。


### 理解复合类型的声明


> 变量的定义包括一个基本数据类型（base type）和一组声明符。在同一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同。也就是说，一条定义语句可能定义出不同类型的变量：
> `int i = 1024, *p = &i, &r = i;`
> 很多程序员容易迷惑于基本数据类型和类型修饰符的关系，其实后者不过是声明符的一部分罢了。
> 类型修饰符（*或&）

多级指针. 

> 指向指针的引用引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：
> ```cpp
> int i = 42;
> int *p;       // p是一个int型指针
> int *&r = p;  // r是一个对指针p的引用
> 
> r = &i;       // r引用了一个指针, 因此给r赋值&i就是令p指向i
> *r = 0;       // 解引用r得到i, 也就是p指向的对象, 将i的值改为0
> ```
> 要理解r的类型到底是什么，最简单的办法是从右向左阅读r的定义。离变量名最近的符号（此例中是&r的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号 * 说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。


> **面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清楚它的真实含义。**























## const限定符

> 因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

> **默认状态下，const对象仅在文件内有效**
> 编译器将在编译过程中把用到该变量的地方都替换成对应的值。

> 默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。

> 如果想在多个文件之间共享const对象，必须在变量的定义之前添加extern关键字。

### const的引用


> 术语：常量引用是对const的引用
> C++程序员们经常把词组“对const的引用”简称为“常量引用”，这一简称还是挺靠谱的，不过前提是你得时刻记得这就是个简称而已。
> 严格来说，并不存在常量引用。因为引用不是一个对象，所以我们没法让引用本身恒定不变。事实上，由于C++语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算是常量。引用的对象是常量还是非常量可以决定其所能参与的操作，却无论如何都不会影响到引用和对象的绑定关系本身。


### 指针和const

> 指向常量的指针（pointer to const）不能用于改变其所指对象的值。

> **试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。**


书上这里const指针翻译的不好. 

### 顶层const

> 指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。用名词顶层const（top-level const）表示指针本身是个常量，而用名词底层const（low-level const）表示指针所指的对象是一个常量。


### constexpr和常量表达式

> 常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。

#### constexpr变量

> C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化：
> ```cpp
> constexpr int mf = 20;         // 20是常量表达式
> constexpr int limit = mf + 1;  // mf + 1是常量表达式
> constexpr int sz = size();     // 只有当size是一个constexpr函数时
>                                // 才是一条正确的声明语句
> ```
> 尽管不能使用普通函数作为constexpr变量的初始值，但是正如6.5.2节（第214页）将要介绍的，新标准允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用constexpr函数去初始化constexpr变量了。


> **一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型。**


#### 字面值类型

> 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。
> 到目前为止接触过的数据类型中，算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。其他一些字面值类型将在7.5.6节（第267页）和19.3节（第736页）介绍。
> 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。
> 6.1.1节（第184页）将要提到，函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。同样是在6.1.1节（第185页）中还将提到，允许函数定义一类有效范围超出函数本身的变量，这类变量和定义在函数体之外的变量一样也有固定地址。因此，constexpr引用能绑定到这样的变量上，constexpr指针也能指向这样的变量。

#### 指针和constexpr
> 必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关：
> ```cpp
> const int *p = nullptr;      // p是一个指向整型常量的指针 
> constexpr int *q = nullptr;  // q是一个指向整数的指针常量
> ```
> p和q的类型相差甚远，p是一个指向常量的指针，而q是一个常量指针，其中的关键在于constexpr把它所定义的对象置为了顶层const（参见2.4.3节，第57页）。
> 
> 与其他常量指针类似，constexpr指针既可以指向常量也可以指向一个非常量：
> ```cpp
> constexpr int *np = nullptr;  // np是一个指向整数的指针常量, 其值为空
> int j = 0; 
> constexpr int i = 42;         // i的类型是整型常量
> // i 和 j 都必须定义在函数体之外
> constexpr const int *p = &i;  // p是指针常量, 指向整型常量i
> constexpr int *p1 = &j;       // p1是指针常量, 指向整数j
> ```
























## 处理类型


### 类型别名

传统方法使用关键字typedef, C++11新规定可以使用别名声明(就是用using). 


### auto类型说明符

> C++11新标准引入了auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型。和原来那些只对应一种特定类型的说明符（比如double）不同，auto让编译器通过初始值来推算变量的类型。


> 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
> 首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型：
> ```cpp
> int i = 0, &r = i;
> auto a = r;         // a是一个整数(r是i的别名, 而i是一个整数)
> ```
> 其次，auto一般会忽略掉顶层const（参见2.4.3节，第57页），同时底层const则会保留下来，比如当初始值是一个指向常量的指针时：
> ```cpp
> const int ci = i, &cr = ci;
> auto b = ci;  // b是一个整数(ci的顶层const特性被忽略掉了)
> auto c = cr;  // c是一个整数(cr是ci的别名, ci本身是一个顶层const)
> auto d = &i;  // d是一个整型指针(整数的地址就是指向整数的指针)
> auto e = &ci; // e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
> ```
> 如果希望推断出的auto类型是一个顶层const，需要明确指出：
> ```cpp
> const auto f = ci; // ci的推演类型是int, f是const int
> ```
> 还可以将引用的类型设为auto，此时原来的初始化规则仍然适用：
> ```cpp
> auto &g = ci;       // g是一个整型常量引用, 绑定到ci
> auto &h = 42;       // 错误: 不能为非常量引用绑定字面值
> const auto &j = 42; // 正确: 可以为常量引用绑定字面值
> ```
> 设置一个类型为auto的引用时，初始值中的顶层常量属性仍然保留。和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。

> 要在一条语句中定义多个变量，切记，符号&和 * 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型：
> ```cpp
> auto k = ci, &l = i; // k是整数, l是整型引用
> auto &m = ci, *p = &ci; // m是对整型常量的引用, p是指向整型常量的指针
> // 错误: i的类型是int而&ci的类型是const int
> auto &n = i, *p2 = &ci;
> ```


### decltype类型指示符


> 类型说明符decltype，它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：
> `decltype(f()) sum = x; // sum的类型就是函数f的返回类型`
> 编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。换句话说，编译器为sum指定的类型是什么呢？就是假如f被调用的话将会返回的那个类型。

> decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）


#### decltype和引用

> 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如4.1.1节（第120页）将要介绍的，有些表达式将向decltype返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：
> ```cpp
> // decltype的结果可以是引用类型
> int i = 42, *p = &i, &r = i;
> decltype(r + 0) b; // 正确: 加法的结果是int, 因此b是一个(未初始化的)int
> decltype(*p) c;    // 错误: c是int&, 必须初始化
> ```
> 因为r是一个引用，因此decltype（r）的结果是引用类型。如果想让结果类型是r所指的类型，可以把r作为表达式的一部分，如r+0，显然这个表达式的结果将是一个具体值而非一个引用。
> 另一方面，如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype（*p）的结果类型就是int&，而非int。

> decltype和auto的另一处重要区别是，decltype的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的decltype就会得到引用类型：
> ```
> // decltype的表达式如果是加上了括号的变量, 结果将是引用
> decltype((i)) d; // 错误: d是int&, 必须初始化
> decltype(i) e;   // 正确: e是一个(未初始化的)int
> ```


> **切记：decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。**

























## 自定义数据结构

### 定义Sales_data类型

struct结构体

> C++11新标准规定，可以为数据成员提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化（参见2.2.1节，第40页）。因此当定义Sales_data的对象时，units_sold和revenue都将初始化为0，bookNo将初始化为空字符串。
> 对类内初始值的限制与之前（参见2.2.1节，第39页）介绍的类似：或者放在花括号里，或者放在等号右边，记住不能使用圆括号。


### 使用Sales_data类

### 编写自己的头文件


#### 预处理器概述

> 确保头文件多次包含仍能安全工作的常用技术是预处理器（preprocessor），它由C++语言从C语言继承而来。预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。之前已经用到了一项预处理功能#include，当预处理器看到#include标记时就会用指定的头文件的内容代替#include。
> C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量（参见2.3.2节，第48页）。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：#ifdef当且仅当变量已定义时为真，#ifndef当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。
>
> 整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般把预处理变量的名字全部大写。


> **头文件即使（目前还）没有被包含在任何其他头文件中，也应该设置保护符。头文件保护符很简单，程序员只要习惯性地加上就可以了，没必要太在乎你的程序到底需不需要。**

























## 小结






















## 术语表


> 地址（address）是一个数字，根据它可以找到内存中的一个字节。
> 别名声明（alias declaration）为另外一种类型定义一个同义词：使用“名字=类型”的格式将名字作为该类型的同义词。
> 算术类型（arithmetic type） 布尔值、字符、整数、浮点数等内置类型。
> 数组（array）是一种数据结构，存放着一组未命名的对象，可以通过索引来访问这些对象。3.5节将详细介绍数组的知识。
> auto 是一个类型说明符，通过变量的初始值来推断变量的类型。
> 基本类型（base type）是类型说明符，可用const修饰，在声明语句中位于声明符之前。基本类型提供了最常见的数据类型，以此为基础构建声明符。
> 绑定（bind）令某个名字与给定的实体关联在一起，使用该名字也就是使用该实体。例如，引用就是将某个名字与某个对象绑定在一起。
> 字节（byte）内存中可寻址的最小单元，大多数机器的字节占8位。
> 类成员（class member）类的组成部分。
> 复合类型（compound type）是一种类型，它的定义以其他类型为基础。
> const是一种类型修饰符，用于说明永不改变的对象。const对象一旦定义就无法再赋新值，所以必须初始化。
> 常量指针（const pointer）是一种指针，它的值永不改变。
> 常量引用（const reference）是一种习惯叫法，含义是指向常量的引用。
> 常量表达式（const expression）能在编译时计算并获取结果的表达式。
> constexpr是一种函数，用于代表一条常量表达式。6.5.2节（第214页）将介绍constexpr函数。
> 转换（conversion）一种类型的值转变成另外一种类型值的过程。C++语言支持内置类型之间的转换。
> 数据成员（data member）组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。
> 声明（declaration）声称存在一个变量、函数或是别处定义的类型。名字必须在定义或声明之后才能使用。
> 声明符（declarator）是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。
> decltype是一个类型说明符，从变量或表达式推断得到类型。
> 默认初始化（default initialization）当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为0；局部作用域的对象未被初始化即拥有未定义的值。
> 定义（definition）为某一特定类型的变量申请存储空间，可以选择初始化该变量。名字必须在定义或声明之后才能使用。
> 转义序列（escape sequence）字符特别是那些不可打印字符的替代形式。转义以反斜线开头，后面紧跟一个字符，或者不多于3个八进制数字，或者字母x加上1个十六进制数。
> 全局作用域（global scope）位于其他所有作用域之外的作用域。
> 头文件保护符（header guard）使用预处理变量以防止头文件被某个文件重复包含。
> 标识符（identifier）组成名字的字符序列，标识符对大小写敏感。
> 类内初始值（in-class initializer）在声明类的数据成员时同时提供的初始值，必须置于等号右侧或花括号内。在作用域内（in scope）名字在当前作用域内可见。
> 被初始化（initialized）变量在定义的同时被赋予初始值，变量一般都应该被初始化。
> 内层作用域（inner scope）嵌套在其他作用域之内的作用域。
> 整型（integral type）参见算术类型。
> 列表初始化（list initialization）利用花括号把一个或多个初始值放在一起的初始化形式。
> 字面值（literal）是一个不能改变的值，如数字、字符、字符串等。单引号内的是字符字面值，双引号内的是字符串字面值。
> 局部作用域（local scope）是块作用域的习惯叫法。
> 底层const（low-level const）一个不属于顶层的const，类型如果由底层常量定义，则不能被忽略。
> 成员（member）类的组成部分。
> 不可打印字符（nonprintable character）不具有可见形式的字符，如控制符、退格、换行符等。
> 空指针（null pointer）值为0的指针，空指针合法但是不指向任何对象。
> nullptr是表示空指针的字面值常量。
> 对象（object）是内存的一块区域，具有某种类型，变量是命名了的对象。
> 外层作用域（outer scope）嵌套着别的作用域的作用域。
> 指针（pointer）是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者0。
> 指向常量的指针（pointer to const）是一个指针，存放着某个常量对象的地址。指向常量的指针不能用来改变它所指对象的值。
> 预处理器（preprocessor）在C++编译过程中执行的一段程序。
> 预处理变量（preprocessor variable）由预处理器管理的变量。在程序编译之前，预处理器负责将程序中的预处理变量替换成它的真实值。
> 引用（reference）是某个对象的别名。
> 对常量的引用（reference to const）是一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。
> 作用域（scope）是程序的一部分，在其中某些名字有意义。C++有几级作用域：
> 全局（global）——名字定义在所有其他作用域之外。
> 类（class）——名字定义在类内部。
> 命名空间（namespace）——名字定义在命名空间内部。
> 块（block）——名字定义在块内部。名字从声明位置开始直至声明语句所在的作用域末端为止都是可用的。
> 分离式编译（separate compilation）把程序分割为多个单独文件的能力。
> 带符号类型（signed）保存正数、负数或0的整型。
> 字符串（string）是一种库类型，表示可变长字符序列。
> struct是一个关键字，用于定义类。
> 临时值（temporary）编译器在计算表达式结果时创建的无名对象。为某表达式创建了一个临时值，则此临时值将一直存在直到包含有该表达式的最大的表达式计算完成为止。
> 顶层const（top-level const）是一个const，规定某对象的值不能改变。
> 类型别名（type alias）是一个名字，是另外一个类型的同义词，通过关键字typedef或别名声明语句来定义。
> 类型检查（type checking）是一个过程，编译器检查程序使用某给定类型对象的方式与该类型的定义是否一致。
> 类型说明符（type specifier）类型的名字。
> typedef为某类型定义一个别名。当关键字typedef作为声明的基本类型出现时，声明中定义的名字就是类型名。
> 未定义（undefined）即C++语言没有明确规定的情况。不论是否有意为之，未定义行为都可能引发难以追踪的运行时错误、安全问题和可移植性问题。
> 未初始化（uninitialized）变量已定义但未被赋予初始值。一般来说，试图访问未初始化变量的值将引发未定义行为
> 无符号类型（unsigned）保存大于等于0的整型。
> 变量（variable）命名的对象或引用。C++语言要求变量要先声明后使用。
> void * 可以指向任意非常量的指针类型，不能执行解引用操作。
> void类型 是一种有特殊用处的类型，既无操作也无值。不能定义一个void类型的变量。
> 字（word）在指定机器上进行整数运算的自然单位。一般来说，字的空间足够存放地址。32位机器上的字通常占据4个字节。
> &运算符（&operator）取地址运算符。
> * 运算符（* operator）解引用运算符。解引用一个指针将返回该指针所指的对象，为解引用的结果赋值也就是为指针所指的对象赋值。
> #define是一条预处理指令，用于定义一个预处理变量。
> #endif是一条预处理指令，用于结束一个
> #ifdef或#ifndef区域。#ifdef是一条预处理指令，用于判断给定的变量是否已经定义。
> #ifndef是一条预处理指令，用于判断给定的变量是否尚未定义。





















