
# ch08. IO库


















## IO类

### IO对象无拷贝或赋值

> 由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型（参见6.2.1节，第188页）。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。

### 条件状态

#### 查询流的状态

#### 管理条件状态

### 管理输出缓冲

> 每个输出流都管理一个缓冲区，用来保存程序读写的数据。

> 有了缓冲机制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很耗时，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。

> 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：  
> · 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。  
> · 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。  
> · 我们可以使用操纵符如endl（参见1.2节，第6页）来显式刷新缓冲区。  
> · 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。  
> · 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。

#### 刷新输出缓冲区

> 我们已经使用过操纵符endl，它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符；ends向缓冲区插入一个空字符，然后刷新缓冲区

#### unitbuf操纵符

> 如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：
> ```cpp
> cout << unitbuf;   // 所有输出操作后都会立刻刷新缓冲区
> // 任何输出都立即刷新, 无缓冲
> cout << nounitbuf; // 回到正常的缓冲方式
> ```

#### 警告：如果程序崩溃，输出缓冲区不会被刷新

> **如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。**
> 
> **当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。**

#### 关联输入和输出流

> 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。

> tie有两个重载的版本（参见6.4节，第206页）：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie（&o）将流x关联到输出流o。




















## 文件输入输出

### 使用文件流对象

#### 用fstream代替iostream&

#### 成员函数open和close

> 如果我们定义了一个空文件流对象，可以随后调用open来将它与文件关联起来

> 因为调用open可能失败，进行open是否成功的检测通常是一个好习惯

> 一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件

#### 自动构造和析构

> 当一个fstream对象被销毁时，close会自动被调用。

### 文件模式

> 每个流都有一个关联的文件模式（file mode），用来指出如何使用文件。表8.4列出了文件模式和它们的含义。
> 
> |表8.4|文件模式|
> |:-|:-|
> |in|以读方式打开|
> |out|以写方式打开|
> |app|每次写操作前均定位到文件末尾|
> |ate|打开文件后立即定位到文件末尾|
> |trunc|截断文件|
> |binary|以二进制方式进行IO|
> 
> 无论用哪种方式打开文件，我们都可以指定文件模式，调用open打开文件时可以，用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：  
> · 只可以对ofstream或fstream对象设定out模式。  
> · 只可以对ifstream或fstream对象设定in模式。  
> · 只有当out也被设定时才可设定trunc模式。  
> · 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。  
> · 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作（参见17.5.3节，第676页，将介绍对同一个文件既进行输入又进行输出的方法）。  
> · ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。
>
> 每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。


#### 以out模式打开文件会丢弃已有数据

> 保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。

#### 每次调用open时都会确定文件模式

> 对于一个给定流，每当打开文件时，都可以改变其文件模式。

> 在每次打开文件时，都要设置文件模式，可能是显式地设置，也可能是隐式地设置。当程序未指定模式时，就使用默认值。



















## string流

### 使用istringstream

> 当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。

#### 使用ostringstream

> 当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。

```cpp
ostringstream b;
//... 
os << b.str() << endl; // 用这个.str()
```



















## 小结
















## 术语表


> 条件状态（condition state）可被任何流类使用的一组标志和函数，用来指出给定流是否可用。
> 
> 文件模式（file mode）类fstream定义的一组标志，在打开文件时指定，用来控制文件如何被使用。
> 
> 文件流（file stream）用来读写命名文件的流对象。除了普通的iostream操作，文件流还定义了open和close成员。成员函数open接受一个string或一个C风格字符串参数，指定要打开的文件名，它还可以接受一个可选的参数，指明文件打开模式。成员函数close关闭流所关联的文件，调用close后才可以调用open打开另一个文件。
> 
> fstream 用于同时读写一个相同文件的文件流。默认情况下，fstream以in和out模式打开文件。
> 
> ifstream 用于从输入文件读取数据的文件流。默认情况下，ifstream以in模式打开文件。
> 
> 继承（inheritance）程序设计功能，令一个类型可以从另一个类型继承接口。类ifstream和istringstream继承自istream，ofstream和ostringstream继承自ostream。第15章将介绍继承。
>
> istringstream 用来从给定string读取数据的字符串流。
> 
> ofstream 用来向输出文件写入数据的文件流。默认情况下，ofstream以out模式打开文件。
> 
> 字符串流（string stream）用于读写string的流对象。除了普通的iostream操作外，字符串流还定义了一个名为str的重载成员。调用str的无参版本会返回字符串流关联的string。调用时传递给它一个string参数，则会将字符串流与该string的一个拷贝相关联。
> 
> stringstream 用于读写给定string的字符串流。















